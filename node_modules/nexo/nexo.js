"use strict";

/*
 * Declarations 
 */
var net = require('net'),
    util = require('util'),
    debug = require('debug')('nexo'),
    queue_debug = require('debug')('queue'),
    callback_debug = require('debug')('callback');

/*
 * Exported object
 */
function Nexo(options) {
    if (!(this instanceof Nexo)) return new Nexo(options);

    // Call constructor of parrent object
    net.Socket.call(this, options);

    this.state = 'disconnected';
    this.callback = null; // callback function
    this.errorback = null;

    this.host = null;
    this.port = null;
    this.pass_md5 = null;
    this.card_addr = null;
    
    this.read_mode = false; // When true, we need to read from Nexo after CMD OK

    this.buffer = ''; // The buffer with answer from the nexo system
    this.message_queue = []; // The buffer for messages

    // set listeners
    this.on('data', nexoOnData);
    this.on('connect', nexoOnConnect);
    this.on('close', nexoOnClose);
    this.on('end', nexoOnEnd);
    this.on('timeout', nexoOnTimeout);
    this.on('drain', nexoOnDrain);
    this.on('error', nexoOnError);

    this.setTimeout(1000);
    this.setKeepAlive(true, 5000);
}
// Set inheretence
util.inherits(Nexo, net.Socket);

// Exported methods
Nexo.prototype.sendNextMessage = function (priority) {
    // This can can be called only when the Nexo replied and reply was processed
    if ((this.state == 'connected') || priority == true) {
        queue_debug('Sending \n' + util.inspect(this.message_queue));
        if (this.message_queue.length > 0) {
          var message = this.message_queue.shift();
          this.state = 'busy';
          queue_debug('sendNextMessage <' + message.payload + '>');
          this.callback = message.callback || this.callback;
          this.read_mode = message.read_mode;
          this.write(message.payload);
        } else {
          queue_debug('no more messages');
        }
    } else {
        queue_debug('sendNextMessage called in state ' +  this.state);
    }
}

Nexo.prototype.messageReceived = function () {
    if (this.state == 'busy') {
      queue_debug('messageReceived');
      this.state = 'connected';   
      //this.sendNextMessage();     
    } else {
      queue_debug('messageReceived called in state ' + this.state);
    }
}

Nexo.prototype.scheduleMessage = function(priority, payload, read_mode, callback) {
    if (priority) { // put at beginning of queue
       this.message_queue.unshift({"payload": payload, "read_mode": read_mode, "callback": callback });
    } else { // schedule at the end
       this.message_queue.push({"payload": payload, "read_mode": read_mode, "callback": callback });
    }
    queue_debug('Added \n' + util.inspect(this.message_queue));

    // When the queue was empty, we need to make it run
    this.sendNextMessage(priority);
}

Nexo.prototype.setConfig = function (config) {
    debug('Set to \n ' + util.inspect(config));
    this.host = this.host || config.host;
    this.port = this.port || config.port;
    this.pass_md5 = this.pass_md5 || config.pass_md5 || require('crypto').createHash('md5').update(config.password).digest('hex');
    this.card_addr = this.card_addr || config.card_addr;
}

Nexo.prototype.getConfig = function() {
    return {host: this.host, port: this.port, pass_md5: this.pass_md5, card_addr: this.card_addr};
}

Nexo.prototype.connectTo = function(callback) {
    // This is done imediatelly, without messaging buffer
    this.callback = callback;
    this.state = 'connecting';
    return this.connect(this.port, this.host);
}

Nexo.prototype.encodeAndWrite = function(priority, data, read_mode, callback) {
    debug('@' + this.card_addr + ':' + data  + '\0');
    return this.scheduleMessage(priority, '@' + this.card_addr + ':' + data  + '\0', read_mode, callback);
}

Nexo.prototype.writeTo = function(priority, data, callback) {
    return this.encodeAndWrite(priority, data, false, callback);
}

Nexo.prototype.readFrom = function(data, callback) {
    return this.encodeAndWrite(false, data, true, callback);
}

Nexo.prototype.poolFrom = function(callback) {
    return this.scheduleMessage(false, '\0', true, callback);
}

Nexo.prototype.ping = function(callback) {
    return this.writeTo(false, 'ping', callback);
}

Nexo.prototype.fixName = function(name) {
    var buf = name.trim();
    if ((buf.indexOf("'")<0) && buf.indexOf(' ')) buf = "'" + buf + "'";
    return buf;
}

Nexo.prototype.switchOn = function(resource, callback) {
    return this.writeTo(false, 'system command wlacz ' + this.fixName(resource), callback);
}

Nexo.prototype.switchOff = function(resource, callback) {
    return this.writeTo(false, 'system command wylacz ' + this.fixName(resource), callback);
}

Nexo.prototype.checkState = function(resource, callback) {
    return this.readFrom('system command stan ' + this.fixName(resource), callback);
}

Nexo.prototype.bufferLength = function() {
    return this.buffer.length;
}

Nexo.prototype.readBuffer = function() {
    var temp = this.buffer;
    this.buffer = '';
    return temp;
}

module.exports = Nexo;


/*
 * Utility functions
 */

// Convert hex to ASCII
function hex2a(hexx) {
    var hex = hexx.toString();//force conversion
    var out = new Buffer(hex.length/2);
    for (var i = 0; i < hex.length; i += 2) {
        out.writeUInt8(parseInt(hex.substr(i, 2), 16),i/2);
    }
    return out;
}

// Sleep
function sleep(milliseconds) {
  var start = new Date().getTime();
  for (var i = 0; i < 1e7; i++) {
    if ((new Date().getTime() - start) > milliseconds){
      break;
    }
  }
}

/*
 * Implementation of socket handling
 */

// Add a 'close' event handler for the nexo_client socket
function nexoOnConnect() {

    debug('Connection opened');

};

// Add a 'data' event handler for the nexo_client socket
// data is what the server sent to this socket
function nexoOnData(data) {
    
    debug('DATA: ' + data.toString());
    
    switch (data.toString()) {
    case 'Welcome to AISIS server.':
        this.write('plain\n\0');
        break;
    case 'NO uSSL':
        this.write(new Buffer(hex2a(this.pass_md5 || require('crypto').createHash('md5').update(this.password).digest('hex'))));
        break;
    case 'LOGIN FAILED':
        this.destroy();
        // errorback?
        break;
    case 'LOGIN OK':
        this.write('!\0');
        this.buffer = '';
        this.state = 'connected';
        this.message_queue = []; // Reset the messages queue
        callback_debug('Callback \n' + this.callback.toString());
        if (this.callback) this.callback.call(); // Connection callback (unscheduled)
        this.sendNextMessage();
        break;
    case 'CMD OK':
        this.buffer = '';
        if (this.read_mode) {
            this.read_mode = false;
            this.writeTo(true, 'get', this.callback); // insert in front of queue
        } else {
            this.messageReceived();
            callback_debug('Callback \n' + this.callback.toString());
            if (this.callback) this.callback.call(); // CMD OK call
            this.sendNextMessage();
        }
        break;
    default:
        if (data.toString().substr(0,9)=='~' + this.card_addr) {
            this.buffer = data.toString().substr(10, data.length - 10);
            debug(this.buffer);
            this.messageReceived();
            callback_debug('Callback \n' + this.callback.toString());            
            if (this.callback) this.callback.call(); // Data call
            this.sendNextMessage();
            //mqtt_client.publish(this.mqtt.root + '/' + this.card_addr + '/' + data.toString().substr(10,data.length - 10))
        } else {
            debug('? ' + data[0] + ' ' + data);
            this.messageReceived();
            if (this.errorback) ;
            this.sendNextMessage();            
        }
    }
};

// Add a 'close' event handler for the nexo_client socket
function nexoOnClose() {
    debug('Connection closed');

};

// Add a 'end' event handler for the nexo_client socket
function nexoOnEnd() {
    debug('Connection ended');

    this.state = 'disconnected';
    this.callback = null; // callback function
    this.errorback = null;
    this.read_mode = false; // When true, we need to read from Nexo after CMD OK
    this.buffer = ''; // The buffer with answer from the nexo system
    this.message_queue = []; // The buffer for messages
};

// Add a 'timeout' event handler for the nexo_client socket
function nexoOnTimeout() {
    debug('Connection timed out');

    this.messageReceived();
    if (this.errorback) ;
    this.sendNextMessage();            
};

// Add a 'drain' event handler for the nexo_client socket
function nexoOnDrain() {

    debug('Connection drained');

};

// Add a 'error' event handler for the nexo_client socket
function nexoOnError() {

    debug('Connection error');

};
