/*
 * Declarations 
 */
var net = require('net'),
    util = require('util'),
    debug = require('debug')('nexo')

/*
 * Exported object
 */
function Nexo(options) {
    if (!(this instanceof Nexo)) return new Nexo(options);

    // Call constructor of parrent object
    net.Socket.call(this, options);

    this.state = 'disconnected';
    this.callback = null; // callback function
    this.errorback = null;

    this.host = null;
    this.port = null;
    this.pass_md5 = null;
    this.card_addr = null;
    
    this.read_mode = false; // When true, we need to read from Nexo after CMD OK

    this.buffer = ""; // The buffer with answer from the nexo system

    // set listeners
    this.on('data', nexoOnData);
    this.on('connect', nexoOnConnect);
    this.on('close', nexoOnClose);
    this.on('end', nexoOnEnd);
    this.on('timeout', nexoOnTimeout);
    this.on('drain', nexoOnDrain);
    this.on('error', nexoOnError);


}
// Set inheretence
util.inherits(Nexo, net.Socket);

// Exported methods
Nexo.prototype.setConfig = function (config) {
    debug('Set to \n ' + util.inspect(config));
    this.host = this.host || config.host;
    this.port = this.port || config.port;
    this.pass_md5 = this.pass_md5 || config.pass_md5 || require('crypto').createHash('md5').update(config.password).digest('hex');
    this.card_addr = this.card_addr || config.card_addr;
}

Nexo.prototype.getConfig = function() {
    return {host: this.host, port: this.port, pass_md5: this.pass_md5, card_addr: this.card_addr};
}

Nexo.prototype.connectTo = function(callback) {
    this.callback = callback;
    this.state = 'connecting';
    return this.connect(this.port, this.host);
}

Nexo.prototype.encodeAndWrite = function(data) {
    debug('@' + this.card_addr + ':' + data  + '\0');
    return this.write('@' + this.card_addr + ':' + data  + '\0');
}

Nexo.prototype.writeTo = function(data, callback) {
    this.callback = callback;
    this.read_mode = false;
    return this.encodeAndWrite(data);
}

Nexo.prototype.readFrom = function(data, callback) {
    this.callback = callback;
    this.read_mode = true;
    return this.encodeAndWrite(data);
}

Nexo.prototype.poolFrom = function(callback) {
    this.callback = callback;
    this.read_mode = true;
    return this.write('\0');
}

Nexo.prototype.ping = function(callback) {
    return this.writeTo('ping', callback);
}

Nexo.prototype.fixName = function(name) {
    var buf = name.trim();
    if ((buf.indexOf("'")<0) && buf.indexOf(' ')) buf = "'" + buf + "'";
    return buf;
}

Nexo.prototype.switchOn = function(resource, callback) {
    return this.writeTo('system command wlacz ' + this.fixName(resource), callback);
}

Nexo.prototype.switchOff = function(resource, callback) {
    return this.writeTo('system command wylacz ' + this.fixName(resource), callback);
}

Nexo.prototype.checkState = function(resource, callback) {
    return this.readFrom('system command stan ' + this.fixName(resource), callback);
}

module.exports = Nexo;


/*
 * Utility functions
 */

// Convert hex to ASCII
function hex2a(hexx) {
    var hex = hexx.toString();//force conversion
    var out = new Buffer(hex.length/2);
    for (var i = 0; i < hex.length; i += 2) {
        out.writeUInt8(parseInt(hex.substr(i, 2), 16),i/2);
    }
    return out;
}

// Sleep
function sleep(milliseconds) {
  var start = new Date().getTime();
  for (var i = 0; i < 1e7; i++) {
    if ((new Date().getTime() - start) > milliseconds){
      break;
    }
  }
}



/*
 * Implementation of socket handling
 */

// Add a 'close' event handler for the nexo_client socket
function nexoOnConnect() {

    debug('Connection opened');

};

// Add a 'data' event handler for the nexo_client socket
// data is what the server sent to this socket
function nexoOnData(data) {
    
    debug('DATA: ' + data);
    
    if (data=='Welcome to AISIS server.') {
        this.write('plain\n\0');
    } else if (data == 'NO uSSL') {
        this.write(new Buffer(hex2a(this.pass_md5 || require('crypto').createHash('md5').update(this.password).digest('hex'))));
    } else if (data == 'LOGIN FAILED') {
        this.destroy();
    } else if (data == 'LOGIN OK') {
        this.write('!\0');
        this.encodeAndWrite('system info nexo-node connected!');
    } else if (data == 'CMD OK') {
        if (this.state == 'connecting') {
            this.state = 'connected';
            if (this.callback) this.callback.call();
        } else if (this.read_mode) {
            this.writeTo('get', this.callback);
        } else if (this.callback) this.callback.call();
    } else if (data.toString().substr(0,9)=='~' + this.card_addr) {
        this.buffer = data.toString().substr(10, data.length - 10);
        debug(this.buffer);
        if (this.callback) this.callback.call();
        //mqtt_client.publish(this.mqtt.root + '/' + this.card_addr + '/' + data.toString().substr(10,data.length - 10))
    } else {
        debug('?' + data[0]);
        if (this.errorback) ;
        //nexo_client.destroy();
    }

};

// Add a 'close' event handler for the nexo_client socket
function nexoOnClose() {

    debug('Connection closed');

};

// Add a 'end' event handler for the nexo_client socket
function nexoOnEnd() {

    debug('Connection ended');

};

// Add a 'timeout' event handler for the nexo_client socket
function nexoOnTimeout() {

    debug('Connection timed out');

};

// Add a 'drain' event handler for the nexo_client socket
function nexoOnDrain() {

    debug('Connection drained');

};

// Add a 'error' event handler for the nexo_client socket
function nexoOnError() {

    debug('Connection error');

};
