/*
 * Declarations 
 */
var net = require('net'),
    util = require('util'),
    debug = require('debug')('nexo');

/*
 * Exported object
 */
function Nexo(config, options) {
    if (!(this instanceof Nexo)) return new Nexo(config, options);

    // Call constructor of parrent object
    net.Socket.call(this, options);

    this.state = 'disconnected';
    //this.callback = null; // callback function used for additional callback for read
    //this.errorback = null;

    debug('Set to \n ' + util.inspect(config));
    this.host = config.host;
    this.port = config.port;
    this.pass_md5 = config.pass_md5 || require('crypto').createHash('md5').update(config.password).digest('hex');
    this.card_addr = config.card_addr;
    
    this.buffer = ""; // The buffer with answer from the nexo system

    // set listeners
    this.on('data', nexoOnData);
    this.on('connect', nexoOnConnect);
    this.on('close', nexoOnClose);
    this.on('end', nexoOnEnd);
    this.on('timeout', nexoOnTimeout);
    this.on('drain', nexoOnDrain);
    this.on('error', nexoOnError);

}
// Set inheretence
util.inherits(Nexo, net.Socket);

// Exported methods
Nexo.prototype.setConfig = function (config) {
    debug('Set to \n ' + util.inspect(config));
    this.host = this.host || config.host;
    this.port = this.port || config.port;
    this.pass_md5 = this.pass_md5 || config.pass_md5 || require('crypto').createHash('md5').update(config.password).digest('hex');
    this.card_addr = this.card_addr || config.card_addr;
}

Nexo.prototype.getConfig = function() {
    return {host: this.host, port: this.port, pass_md5: this.pass_md5, card_addr: this.card_addr};
}

Nexo.prototype.connectTo = function() {
    this.state = 'disconnected';
    return this.connect(this.port, this.host);
}

<<<<<<< HEAD
Nexo.prototype.registerReadCallback = function(callback) {
    
    // this function is unfinished

    this.callback = callback;
=======
Nexo.prototype._encodeAndWrite = function (data) {
    debug('Encode @' + this.card_addr + ':' + data  + '\0');
    return this.write('@' + this.card_addr + ':' + data  + '\0');
>>>>>>> FETCH_HEAD
}

Nexo.prototype.decodeState = function (data) {
    debug('Decode State %s', data);
    var array = data.toString().split(' ');
    var answer = {name: array[0]};    

    if (array.length>3) for (i=1; i<array.length-2; i++) answer.name += ' ' + array[i];

    switch (array[array.length-1]) {
        case 'wlaczone': 
            answer.state = 'on'; break;
        case 'wylaczone':
            answer.state = 'off'; break;
        case 'uzbrojona':
            answer.state = 'armed'; break;
        case 'rozbrojona':
            answer.state = 'disarmed'; break;
        default:
            // leave unknown
    }

    debug('Decoded to %s ', util.inspect(answer));
    return answer;
}

Nexo.prototype._writeTo = function (data) {
    this.state = 'writing';
    return this._encodeAndWrite(data);
}

Nexo.prototype._readFrom = function (data) {
    this.state = 'reading';
    return this._encodeAndWrite(data);
}

Nexo.prototype.poolFrom = function() {
    // No change of state here, should be 'connected'
    return this.write('\0');
}

Nexo.prototype.ping = function() {
    this.state = 'ping';
    return this._encodeAndWrite('ping');
}

Nexo.prototype.fixName = function (name) {
    var buf = name.trim();
    if ((buf.indexOf("'")<0) && buf.indexOf(' ')) buf = "'" + buf + "'";
    return buf;
}

Nexo.prototype.switchOn = function (resource) {
    return this._writeTo('system command wlacz ' + this.fixName(resource));
}

Nexo.prototype.switchOff = function (resource) {
    return this._writeTo('system command wylacz ' + this.fixName(resource));
}

Nexo.prototype.checkState = function (resource) {
    return this._readFrom('system command stan ' + this.fixName(resource));
}

module.exports = Nexo;

/*
 * Utility functions
 */

// Convert hex to ASCII
function hex2a(hexx) {
    var hex = hexx.toString();//force conversion
    var out = new Buffer(hex.length/2);
    for (var i = 0; i < hex.length; i += 2) {
        out.writeUInt8(parseInt(hex.substr(i, 2), 16),i/2);
    }
    return out;
}

/*
 * Implementation of socket handling
 */

// Add a 'close' event handler for the nexo_client socket
function nexoOnConnect() {

    debug('Connection opened');

};

// Add a 'data' event handler for the nexo_client socket
// data is what the server sent to this socket
function nexoOnData(data) {
    
<<<<<<< HEAD
    debug('DATA: ' + data + ' @ state: ' + this.state);
    
    if (data=='Welcome to AISIS server.') {
        this.write('plain\n\0');
    } else if (data == 'NO uSSL') {
        this.write(new Buffer(hex2a(this.pass_md5 || require('crypto').createHash('md5').update(this.password).digest('hex'))));
    } else if (data == 'LOGIN FAILED') {
        this.destroy();
    } else if (data == 'LOGIN OK') {
        this.write('!\0');
        this.encodeAndWrite('system info nexo-node connected!');
    } else if (data == 'CMD OK') {
        if (this.state == 'connecting') {
            debug('Connected');
            this.state = 'connected';
            if (this.callback) this.callback.call(this.state);
        } else if (this.read_mode) {
            debug('Reading');
            this.state = 'reading';
            this.writeTo('get');
        } else {
            debug('Other...');
            if (this.callback) this.callback.call();
        }
    } else if (data.toString().substr(0,9)=='~' + this.card_addr) {
        this.buffer = data.toString().substr(10, data.length - 10);
        debug(this.buffer);
        if (this.callback) this.callback.call(this.state, this.buffer);
        // Keep pinging
=======
    debug('DATA: %s in state %s', data, this.state);

    // Remove all spaces
    var dataNoSpaces = data.toString();
    while (dataNoSpaces.search(' ') >= 0) dataNoSpaces = dataNoSpaces.replace(' ', '');

    switch(this.state) {

        // Completly disconnected
        case 'disconnected':
            // Remove all spaces

            switch (dataNoSpaces) {

                case 'WelcometoAISISserver.':
                    this.state = 'connecting';
                    this.write('plain\n\0');
                    break;

                default: 
                    debug('Unexpected data received [%s] in state', data, this.state);
                    this.emit('nexo_disconnected', 'not_nexo');
            }
            break;

        // Currently in the connecting process
        case 'connecting':
 
            switch (dataNoSpaces) {

                case 'NOuSSL':
                    this.write(new Buffer(hex2a(this.pass_md5 || require('crypto').createHash('md5').update(this.password).digest('hex'))));
                    break;

                case 'LOGINFAILED':
                    this.destroy();
                    this.state = 'login_failed';
                    this.emit('nexo_disconnected', 'login_failed');
                    break;

                case 'LOGINOK':
                    this.write('!\0');
                    this._encodeAndWrite('system info nexo-node connected!');
                    break;

                case 'CMDOK':
                    this.state = 'connected';
                    this.emit('nexo_connected');
                    break;

                default: 
                    debug('Unexpected data received [%s] in state', data, this.state);
                    this.state = 'disconnected';
                    this.emit('nexo_disconnected', 'flow_error');
            }
            break;

        case 'connected':
            // Do nothing here, if connected the poolFrom is emited at the end
            break;

        // In the heartbeat state
        case 'heartbeat':
            switch (dataNoSpaces) {
                // OK
                case 'CMDOK':
                    this.state = 'connected';
                    this.emit('nexo_heartbeat');
                    break;

                // Unhandled response
                default:
                    this.state = 'connected';
                    this.emit('nexo_heartbeat', data)                    
            }
            break;

        // In writting state
        case 'writing':
            switch (dataNoSpaces) {
                // OK
                case 'CMDOK':
                    this.state = 'connected';
                    this.emit('nexo_written');
                    break;

                // Unhandled response
                default:
                    this.state = 'connected';
                    this.emit('nexo_written', data)                    
            }
            break;
        
        // In reading, we will be also listening
        case 'reading':
            switch (dataNoSpaces) {
                // OK
                case 'CMDOK':
                    this.state = 'listening';
                    this._encodeAndWrite('get');
                    break;

                // Unhandled response
                default:
                    this.state = 'connected';
                    this.emit('nexo_read');                    
            }
            break;

        case 'listening':
            if (data.toString().substr(0,9)=='~' + this.card_addr) {
                this.state = 'connected';
                this.buffer = data.toString().substr(10, data.length - 10);
                debug(this.buffer);
                this.emit('nexo_read', this.buffer);
            } else {
                // Keep listening
                debug(this.buffer);
                this.poolFrom();
            }
            break;

        case 'ping':
            if (data.toString().substr(0,14)=='~' + this.card_addr + ':pong') {
                this.state = 'connected';
                this.buffer = data.toString().substr(10, data.length - 10);
                debug(this.buffer);
                this.emit('nexo_pong');
             } else {
                // Keep listening
                debug(this.buffer);
                this.poolFrom();
            }
            break;

        default: debug('Invalid state %s', this.state);

    }

    if (this.state == 'connected') {
        // Emit heartbeat
>>>>>>> FETCH_HEAD
        this.state = 'heartbeat';
        this.poolFrom();
    }
        
}    

// Add a 'close' event handler for the nexo_client socket
function nexoOnClose() {

    debug('Connection closed');
    this.state = 'disconnected';
    this.emit('nexo_disconnected','connection_closed');

};

// Add a 'end' event handler for the nexo_client socket
function nexoOnEnd() {

    debug('Connection ended');

};

// Add a 'timeout' event handler for the nexo_client socket
function nexoOnTimeout() {

    debug('Connection timed out');
    if (this.state == 'connected') this.poolFrom();

};

// Add a 'drain' event handler for the nexo_client socket
function nexoOnDrain() {

    debug('Connection drained');
    if (this.state == 'connected') this.poolFrom();

};

// Add a 'error' event handler for the nexo_client socket
function nexoOnError() {

    debug('Connection error');

};
